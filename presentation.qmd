---
title: "Cricket Match Results Forcasting"
subtitle: "INFO 523 - Spring 2024 - Project Final"
author: "Christian Ortmann, Pappala Praveen Kumar, Poonkundran Srinivasan, Srinivasan Akash, Theeda Gowtham, Tiruthani Rajitha Reddy, Bhawari Tejas"
title-slide-attributes:
  data-background-image: images/round-stadium-cricket-night-with-lights-evening_940927-15512.jpg
  data-background-size: stretch
  data-background-opacity: "0.7"
  data-slide-number: none
format:
  revealjs:
    theme:  ['data/customtheming.scss']
    transition: concave
    background-transition: fade
    scrollable: true
    logo: images/logo DD.png
  
editor: visual
jupyter: python3
execute:
   echo: false
   warning: false
   message: false
editor_options:
    chunk_output_type: console
---

```{python}
#| label: load-packages
#| include: false

# # Load packages here
# import pandas as pd
# import glob
# import seaborn as sns
# from sklearn.preprocessing import MinMaxScaler, LabelEncoder
# from sklearn.feature_selection import SelectKBest, f_classif
# from sklearn.model_selection import train_test_split as tts
# from sklearn.linear_model import LogisticRegression
# from sklearn.tree import DecisionTreeClassifier  
# from sklearn.ensemble import RandomForestClassifier
# from sklearn import metrics
# from sklearn.model_selection import cross_validate
# from sklearn.decomposition import PCA
#from IPython.display import Image
# import matplotlib.pyplot as plt
# import pickle

```

```{python}
#| label: setup
#| include: false
#| 
# # Set up plot theme and figure resolution
# sns.set_theme(style="whitegrid")
# sns.set_context("notebook", font_scale=1.1)

# import matplotlib.pyplot as plt
# plt.rcParams['figure.dpi'] = 300
# plt.rcParams['savefig.dpi'] = 300
# plt.rcParams['figure.figsize'] = (6, 6 * 0.618)
```

```{python}
# #| label: load-data
# #| include: false
# # Load data in Python
# mtcars = sns.load_dataset('mpg').dropna()  # mtcars dataset is similar to the mpg dataset from seaborn
# mtcars['speed'] = mtcars['horsepower'] / mtcars['weight']

# penguins = sns.load_dataset('penguins').dropna()
```

## Introduction {style="font-size: 0.7em;"}

::: incremental
-   Our project predicts the match results by using historical ODI cricket data and state-of-the-art machine learning. It redefines cricket analysis by closely monitoring forecast accuracy and encouraging user engagement.

-   We have considered dataset from year 2002 to 2022 as past data. using this following data we have trainned the following machine learning model to predict the current years match winner (considering 2023 as the current year).
:::

## Project Approach {style="font-size: 0.7em;"}

::: incremental
-   The primary goal of our project is to use past and current match data, train them under regression classification models, select the best model and then use it to predict the winner of a cricket match based on the live match statistics (e.g., runs scored, wickets fallen, overs bowled), that update at regular intervals.

-   This model will be displayed on a webpage which will refresh every time a new stat is updated, and the prediction from the model will update.
:::

## Description of datasets {style="font-size: 0.7em;"}

::: incremental

ODI_Match_Data.csv: Provides facts about the location and season of the cricket matches along with team information and the play results from each team member. We’ll need this one to investigate partnerships between batsmen. It’s dimensions are 155432 rows of data by 23 variable columns.

ODI_Match_info.csv: Overlaps in data with the above but provides information on the umpire, performance, and the city the match took place. We’ll need this one to analyze the batting and bowling performance of each player. It’s dimensions are 2380 rows of data by 18 variable columns.
:::

# Model Building

## Step 1: Exploratory Data Analysis {style="font-size: 0.7em;"}

::: incremental
Here, we first carried out Data Preprocessing where we merged the match_data and match_info files, then carried out Exploratory Data Analysis by using pairplots to find correlations between different variables, if any. ![](images/pairplot.png){fig-align="center" width="1300" height="600"}

```{python}
# info = pd.read_csv('data/ODI_Match_info.csv')
# info = info.rename(columns = {'id':'match_id'})

# #append all files together
# csv_files = ['data/output_1.csv','data/output_2.csv','data/output_3.csv','data/output_4.csv','data/output_5.csv','data/output_6.csv','data/output_7.csv','data/output_8.csv','data/output_9.csv']

# matchData = pd.concat([pd.read_csv(f,low_memory=False) for f in csv_files ], ignore_index=True)

# #merge frames on match ID column

# totalData = pd.merge(matchData, info, on = 'match_id') #merge by identical column 'match_id'
# totalData.drop(totalData.filter(regex='_y$').columns, axis=1, inplace=True) #drop duplicate columns

# totalData = totalData.rename(columns = {'season_x':'season', 'venue_x':'venue'})

# from02to22 = totalData[~totalData['season'].astype(str).str.startswith(('2023/2024','2023', '2022/23'))] #exclude 2023 data

# from02to22
# print(type(from02to22)) #confirm data is read in as a df
# print(from02to22.shape) #confirm data shape
# print(from02to22.dtypes) #understand the types of data in the df
# print(from02to22.isna().sum()) #count NA values in columns
# print(pd.DataFrame.describe(from02to22)) #descriptive function to look at dataframe)


# winners = sns.countplot(data = from02to22, y = 'winner', order=from02to22['winner'].value_counts().index)
# winners

# # corr = sns.pairplot(from02to22)
# corr
```
:::

## Steps 2-4 {style="font-size: 0.7em;"}

::: incremental
-   Step 2: Data Manipulation - During a thorough process of Data Cleaning, we dropped some columns which were largely empty and replaced some empties with ‘Unknown’.

-   Step 3: Feature Engineering - We normalized the continuous data and encoded categorical variables.

-   Step 4 Feature selection - we directly select the top 10 columns except winnerTeam as the input features of the model and the winnerTeam itself as the target feature.

-   The input features are - \['ball', 'batting_team', 'bowling_team', 'non_striker', 'bowler', 'runs_off_bat', 'team1', 'team2', 'toss_winner', 'dl_applied'\]

```{python}
#drop columns that have more than 1Million NaNs

# colNaCounts = from02to22.isna().sum()


# columns_to_drop = colNaCounts[colNaCounts >= 1000000].index.tolist()

# # Drop identified columns from the DataFrame
# from02to22 = from02to22.drop(columns=columns_to_drop)


# #revalue new winner column

# from02to22['winnerTeam'] = from02to22.apply(lambda row: 'team1' if row['winner'] == row['team1'] else 'team2', axis=1)

# #convert Nan cities to 'Unknown'
# #drop winner NA columns
# #convert NA player of match to 'unknown'
# #convert NA umpire 3 to 'unknown'

# from02to22['city'] = from02to22['city'].fillna('Unknown') 
# from02to22['player_of_match'] = from02to22['player_of_match'].fillna('Unknown') 
# from02to22['umpire3'] = from02to22['umpire3'].fillna('Unknown') 
# from02to22 = from02to22.dropna(subset=['winner'])
# from02to22 = from02to22.drop(columns = ['match_id', 'start_date', 'date', 'winner', 'cricsheet_id', 'season', 'venue', 'city', 'player_of_match', 'win_by_runs', 'win_by_wickets', 'umpire1', 'umpire2', 'umpire3', 'result']) #is date specific data really useful? also drop continuous match identifiers. We want the match stats
# # corr = sns.pairplot(from02to22)
# # corr
```
:::

# Model Training and Validation

## Logistic Regression {style="font-size: 0.7em;"}

::: incremental
From the results of Logistic regression, we observe the accuracy and precision of this model is around 55% and the area under ROC curve is also around 0.5. As these metrics show that this might not be the best model, we move forward and train another model.

![](images/lr_roc_curve.png){fig-align="center" width="1300" height="600"}
:::

## Random Forest Classifier {style="font-size: 0.7em;"}

::: incremental
Now we take the Random Forest Classifier, as we observe the accuracy and precision of this model is around 96% and the area under ROC curve is also around 0.96. These metrics clearly show that this is the best model, so we move forward with this model.

![](images/rfc_roc_curve.png){fig-align="center" width="1300" height="600"}
:::

# Implementation {style="font-size: 0.7em;"}

![](images/finalblockdiag.png){fig-align="center" width="1300" height="600"}

::: incremental
```{python}

# Step 3: Load the model from the pickle file

# with open("linear_regression_model.pkl", "rb") as f:
#     loaded_model = pickle.load(f)

```

```{python}

import requests

# url = "https://goto-brought-auction-deck.trycloudflare.com/analyzingtrends/getmatchbyid/1"  
# response = requests.get(url)

# if response.status_code == 200:  # Check if the request was successful
#     json_data = response.json()  # Convert response to JSON format
#     print(json_data['season'])  # Print the JSON data
# else:
#     print("Failed to retrieve data from the API.")

```

```{python}

# loaded_model = None
# 
# # Load the model from the pickle file
# with open("/Users/cortmann/Desktop/523 - Data Mining/localCricketPredictions/cricketPrediction.pkl", "rb") as f:
#     loaded_model = pickle.load(f)
    
# predictRFC = loaded_model.predict(X_test)

# outcomeRFC = pd.DataFrame ({'Actual': y_test, 'Predicted': predictRFC})
# outcomeRFC['Actual'] = label_encoders[9].inverse_transform(outcomeRFC['Actual'])
# outcomeRFC['Predicted'] = label_encoders[9].inverse_transform(outcomeRFC['Predicted'])
    


# cvRF = cross_validate(loaded_model,X_train, y_train)
# print("cross validation of random forest", cvRF)
# print("accuracy of random forest:", metrics.accuracy_score(y_test, predictRFC)) #testing how accuracy of the models
# print("precision of random forest:", metrics.precision_score(y_test, predictRFC, average = 'weighted'))
# print("recall of random forest:", metrics.recall_score(y_test, predictRFC, average = 'weighted'))
# print("f1 of random forest:", metrics.f1_score(y_test, predictRFC, average = 'weighted'))
# print("ROCAUC macro of random forest:", metrics.roc_auc_score(y_test, predictRFC))
# print("ROCAUC micro of random forest:", metrics.roc_auc_score(y_test, predictRFC, average = 'micro'))


# y_pred_proba = loaded_model.predict_proba(X_test)[::,1]
# fpr, tpr, _ = metrics.roc_curve(y_test,  y_pred_proba)
# plt.plot(fpr,tpr)
# plt.ylabel('True Positive Rate')
# plt.xlabel('False Positive Rate')
# plt.title('ROC Curve Random Forest')
# plt.show()

#{fig-align="center" width="1300" height = "600"}
```
:::

# Demonstration

::: incremental

The following links direct us to the webpage where you can find the demonstration of our model which predicts the winner results of ODI 2023 cricket matches.

https://de-cases-articles-premier.trycloudflare.com/

https://indexes-oct-cafe-decided.trycloudflare.com/analyzingtrends/getcurrentlivedata

:::

# Thank You
       
<img src="images/Leonardo Di Caprio.gif" alt="Leonardo Di Caprio" style="display:block; margin:auto; width:1300px; height:600px;">
